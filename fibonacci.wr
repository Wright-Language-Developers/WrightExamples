// finds fibonacci numbers

/! Recursively computes fibonacci numbers
func fibonacci(n: val integer) -> integer {
    if n == 1 || n == 2 { return 1; }
    else {
        return fibonacci_recursive(n-1)+fibonacci_recursive(n-2);
    }
}

// `?! Overload` makes the compiler check for an overloading function (similarly to java)
/? Calculates fibonacci using a loop.
 ? $arg n: nth fibonacci number will be calculated. Assumed to be positive.
 ?/
?! Overload
func fibonacci(n: val i64) -> integer {
    let mut two_back: integer = 1; // starting value only
    let mut prev: integer = 1;
    let mut current: integer = 1;
    for i: i64 in 2..n {    // 2..n generates a range for [2, n)
        current = two_back + prev;
        two_back = prev;
        prev = current;
    }
    return current;
}

